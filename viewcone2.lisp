(in-package #:org.shirakumo.fraf.ld45)

(defconstant EPS 0.075)
(defconstant HALF-AUX-RAY-TILT-COS (cos (->rad 0.5)))
(defconstant HALF-AUX-RAY-TILT-SIN (sin (->rad 0.5)))

(define-shader-entity sector (vertex-entity located-entity)
  ((radius :initarg :radius :initform 512 :accessor radius)
   (radius2 :accessor radius2)
   (direction :initform (vec 1 0) :accessor direction)
   (aperture :initform (->rad 30) :accessor aperture)
   (sector-ledge :initform (vec 0 0) :accessor sector-ledge)
   (sector-redge :initform (vec 0 0) :accessor sector-redge)
   (blocking-edges :initform (make-array 0 :adjustable T :fill-pointer T) :reader blocking-edges)))

(defmethod initialize-instance :after ((sector sector) &key)
  (let ((vbo (make-instance 'vertex-buffer :buffer-data (make-array 0 :adjustable T :fill-pointer T :element-type 'single-float))))
    (setf (vertex-array sector) (make-instance 'vertex-array
                                               :bindings `((,vbo :size 2 :offset 0 :stride 8))
                                               :vertex-form :triangle-fan
                                               :size 0)))
  (setf (radius2 sector) (* (radius sector) (radius sector))))

(defmethod (setf location) :around (new (sector sector))
  (when (v/= new (location sector))
    (call-next-method)
    (update-scene-cache sector +world+)))

(defmethod (setf direction) :around (new (sector sector))
  (when (v/= new (direction sector))
    (call-next-method)
    (update-scene-cache sector +world+)))

(defmethod (setf aperture) :after (_ (sector sector))
  (update-scene-cache sector +world+))

(defmethod (setf radius) :after (_ (sector sector))
  (setf (radius2 sector) (* (radius sector) (radius sector)))
  (update-scene-cache sector +world+))

(defun cross (a b)
  (- (* (vx a) (vy b)) (* (vy a) (vx b))))

(defun perp (v &optional clockwise)
  (if clockwise
      (vec (vy v) (- (vx v)))
      (vec (- (vy v)) (vx v))))

(defun parallel-p (a b)
  (<= (abs (cross a b)) EPS))

(defun inv-lerp (line point)
  (let ((x (v- point (car line)))
        (dir (v- (cdr line) (car line))))
    (/ (v. x dir) (vsqrlen2 dir))))

(defun point-on-line-p (pt line)
  (parallel-p (v- pt (car line)) (v- (cdr line) (car line))))

(defun point-on-line (line x)
  (nv+ (nv* (v- (cdr line) (car line)) x) (car line)))

(defun rotate-dir (dir cos-a sin-a)
  (let ((xc (* (vx dir) cos-a))
        (yc (* (vy dir) cos-a))
        (xs (* (vx dir) sin-a))
        (ys (* (vy dir) sin-a)))
    (cons (vec (- xc ys) (+ xs yc))
          (vec (+ xc ys) (- yc xs)))))

(defun point-seg-shortest-distance (line pt)
  (let* ((e1 (v- pt (car line)))
         (dir (v- (cdr line) (car line)))
         (num (v. e1 dir))
         (s (clamp 0 (/ num (vsqrlen2 dir)) 1)))
    (vsqrlen2 (nv- e1 (nv* dir s)))))

(defun line-circle-xsect (line center r2)
  (< (point-seg-shortest-distance line center) r2))

(defun point-in-sector-p (pt sector)
  (let* ((v (v- pt (location sector)))
         (dot (v. v (direction sector))))
    (cond ((<= dot 0)
           :behind)
          ((< EPS (- (vsqrlen2 v) (radius2 sector)))
           :outside)
          ((and (<= (cross (sector-ledge sector) v) 0)
                (<= (cross v (sector-redge sector)) 0))
           :within)
          (T
           :front))))

(defun line-arc-xsect (line sector)
  (let* ((delta (v- (car line) (location sector)))
         (dir (v- (cdr line) (car line)))
         (b (v. dir delta))
         (d2 (vsqrlen2 dir))
         (c (- (vsqrlen2 delta) (radius2 sector)))
         (det (- (* b b) (* d2 c))))
    (when (< 0 det)
      (let ((detsqrt (sqrt det))
            t1 t2 p1 p2 p1in p2in points)
        (cond ((<= 0 b)
               (let ((tt (+ b detsqrt)))
                 (setf t1 (/ (- tt) d2))
                 (setf t2 (/ (- c) tt))))
              (T
               (let ((tt (- detsqrt b)))
                 (setf t1 (/ c tt))
                 (setf t2 (/ tt d2)))))
        (when (<= 0 t1 1)
          (setf p1 (point-on-line line t1))
          (setf p1in (point-in-sector-p p1 sector))
          (when (eq :within p1in)
            (push p1 points)))
        (when (<= 0 t2 1)
          (setf p2 (point-on-line line t2))
          (setf p2in (point-in-sector-p p2 sector))
          (when (eq :within p2in)
            (push p2 points)))
        (when (or p1 p2)
          (cond ((and (eq p1in :behind) (eq p2in :behind))
                 '(:config :behind))
                (points
                 (list :config :within :points points))))))))

(defun line-line-xsect (line1 line2 &optional compute-point-p line1-ray-p)
  (let* ((result (list :config :disjoint))
         (l1p (perp (v- (cdr line1) (car line1))))
         (f (v. (v- (cdr line2) (car line2)) l1p)))
    (cond ((<= (abs f) EPS)
           (setf (getf result :config) :parallel)
           (when (and line1-ray-p compute-point-p (point-on-line-p (car line2) line1))
             (let ((alpha (inv-lerp line2 (car line1))))
               (cond ((<= 0 alpha 1)
                      (setf (getf result :t) 0)
                      (setf (getf result :point) (car line1)))
                     ((< alpha 0)
                      (setf (getf result :point) (car line2))
                      (setf (getf result :t) (inv-lerp line1 (car line2))))))))
          (T
           (let* ((c (v- (car line1) (car line2)))
                  (e (v. c l1p)))
             (when (or (and (< 0 f) (<= 0 e) (<= e f))
                       (and (< f 0) (<= e 0) (<= f e)))
               (let* ((l2p (perp (v- (cdr line2) (car line2))))
                      (d (v. c l2p)))
                 (when (or (and line1-ray-p (or (and (< 0 f) (<= 0 d))
                                                (and (< f 0) (<= d 0))))
                           (and (< 0 f) (<= 0 d) (<= d f))
                           (and (< f 0) (<= d 0) (<= f d)))
                   (setf (getf result :config) :intersect)
                   (when compute-point-p
                     (let ((s (/ d f)))
                       (setf (getf result :t) s)
                       (setf (getf result :point) (point-on-line line1 s))))))))))
    result))

(defun add-angle-point-with-aux (point prev next sector points)
  (unless (gethash point points)
    (setf (gethash point points) point)
    (let* ((ray (v- point (location sector)))
           (aux (rotate-dir ray HALF-AUX-RAY-TILT-COS HALF-AUX-RAY-TILT-SIN)))
      (nv+ (car aux) (location sector))
      (nv+ (cdr aux) (location sector))
      (let ((proj-axis (perp ray)))
        (cond ((or (null next) (eq next prev))
               (let* ((dir (v- (cdr prev) (car prev)))
                      (line-vec (if (eq point (car prev)) dir (nv* dir -1)))
                      (p (v. line-vec proj-axis)))
                 (cond ((<= p 0)
                        (setf (gethash (car aux) points) (car aux)))
                       ((<= 0 p)
                        (setf (gethash (cdr aux) points) (cdr aux))))))
              (T
               (let ((p1 (v. (v- (cdr prev) (car prev)) proj-axis))
                     (p2 (v. (v- (cdr next) (car next)) proj-axis)))
                 (cond ((and (<= 0 p1) (<= p2 0))
                        (setf (gethash (car aux) points) (car aux)))
                       ((and (<= p1 0) (<= 0 p2))
                        (setf (gethash (cdr aux) points) (cdr aux)))))))))))

(defun check-polygon (edges sector points blocking-edges)
  (flet ((aref? (array i)
           (when (< i (length edges)) (aref array i))))
    (loop for i from 0 below (length edges)
          for prev-edge = (aref edges (1- (length edges))) then edge
          for edge = (aref edges i)
          do (when (line-circle-xsect edge (location sector) (radius2 sector))
               (let ((e1in (point-in-sector-p (car edge) sector))
                     (e2in (point-in-sector-p (cdr edge) sector)))
                 (unless (and (eq :behind e1in) (eq :behind e2in))
                   (cond ((and (eq e1in :within) (eq e2in :within))
                          (add-angle-point-with-aux (car edge) prev-edge edge sector points)
                          (add-angle-point-with-aux (cdr edge) edge (aref? edges (1+ i)) sector points)
                          (vector-push-extend edge blocking-edges))
                         (T
                          (let ((blocking NIL))
                            (when (eq :within e1in)
                              (add-angle-point-with-aux (car edge) prev-edge edge sector points)
                              (setf blocking T))
                            (when (eq :within e2in)
                              (add-angle-point-with-aux (cdr edge) edge (aref? edges (1+ i)) sector points)
                              (setf blocking T))
                            (let ((test-seg-seg-xsect T))
                              (when (or (eq e1in :outside) (eq e2in :outside))
                                (let ((result (line-arc-xsect edge sector)))
                                  (when result
                                    (when (eq (getf result :config) :within)
                                      (loop for point in (getf result :points)
                                            do (setf (gethash point points) point))
                                      (setf blocking T))
                                    (setf test-seg-seg-xsect (not (eq :behind (getf result :config)))))))
                              (flet ((test-edge (other)
                                       (eq :intersect (getf (line-line-xsect edge other) :config))))
                                (cond (blocking
                                       (vector-push-extend edge blocking-edges))
                                      ((and test-seg-seg-xsect
                                            (or (test-edge (cons (location sector) (v+ (location sector) (sector-ledge sector))))
                                                (test-edge (cons (location sector) (v+ (location sector) (sector-redge sector))))))
                                       (vector-push-extend edge blocking-edges))))))))))))))

(defun make-rays (sector points)
  (let* ((ray (v- (aref points 0) (location sector)))
         (rays (list ray)))
    (loop for point across points
          for ray = (v- point (location sector))
          do (unless (parallel-p ray (first rays))
               (push ray rays)))
    (nreverse rays)))

(defun sort-points (points sector)
  (let ((center (location sector)))
    (flet ((thunk (a b)
             (< (cross (v- a center) (v- b center)) 0)))
      (sort points #'thunk))))

(defun calc-quad-bez-curve-ctrl-point (v1 v2 center radius)
  (let ((ctrl (nvunit (v+ v1 v2))))
    (nv+ (nv* ctrl (* radius (- 2 (v. v1 ctrl)))) center)))

(defun shoot-rays (rays blocking-edges sector)
  (let ((this-ray (cons (location sector) NIL))
        (hit-points (make-array (length rays)))
        (ctrl-points (make-array (length rays) :initial-element NIL))
        (prev-point-on-arc NIL) prev-unit-ray)
    (loop for i from 0
          for ray in rays
          do (setf (cdr this-ray) (v+ (car this-ray) ray))
             (let ((hit-point (vec2 0 0))
                   tt blocker hit-dist2)
               (loop for edge across blocking-edges
                     for res = (line-line-xsect this-ray edge T T)
                     do (when (and (getf res :t) (or (null tt) (< (getf res :t) tt)))
                          (setf hit-dist2 (vsqrdist2 (getf res :point) (location sector)))
                          (when (< EPS hit-dist2)
                            (setf tt (getf res :t))
                            (setf hit-point (getf res :point))
                            (setf blocker edge))))
               (let ((point-on-arc (or (null tt) (<= 0 (- (+ hit-dist2 EPS) (radius2 sector))))))
                 (when point-on-arc
                   (let ((unit-ray (if (v= 0 ray) ray (vunit ray))))
                     (setf hit-point (nv+ (v* unit-ray (radius sector)) (location sector)))
                     (when prev-point-on-arc
                       (let ((needs-arc T))
                         (when blocker
                           (setf needs-arc (not (parallel-p (v- (cdr blocker) (car blocker))
                                                            (v- (aref hit-points (1- i)) hit-point)))))
                         (when needs-arc
                           (setf (aref ctrl-points i) (calc-quad-bez-curve-ctrl-point
                                                       unit-ray prev-unit-ray (location sector) (radius sector))))))
                     (setf prev-unit-ray unit-ray)))
                 (setf prev-point-on-arc point-on-arc))
               (setf (aref hit-points i) hit-point)))
    (cons hit-points ctrl-points)))

(defun visible-p (point sector)
  (when (eq :within (point-in-sector-p point sector))
    (let ((ray (cons (location sector) point)))
      (loop for edge across (blocking-edges sector)
            for res = (line-line-xsect ray edge T)
            never (and (eq :intersect (getf res :config))
                       (< EPS (vsqrdist2 (getf res :point) (location sector))))))))

(defgeneric fill-edges (entity target))

(defmethod fill-edges (thing poly))

(defmethod fill-edges ((wall wall) poly)
  (let* ((loc (location wall))
         (bsize (bsize wall))
         (l (- (vx loc) (vx bsize)))
         (r (+ (vx loc) (vx bsize)))
         (b (- (vy loc) (vy bsize)))
         (u (+ (vy loc) (vy bsize)))
         (lb (vec l b)) (rb (vec r b))
         (ru (vec r u)) (lu (vec l u)))
    (when (and (/= 0 (vx bsize)) (/= 0 (vy bsize)))
      (flet ((add (a b)
               (vector-push-extend (cons a b) poly)))
        (add lb rb)
        (add rb ru)
        (add ru lu)
        (add lu lb)
        T))))

(defmethod update-scene-cache ((sector sector) scene)
  (let ((dirs (rotate-dir (direction sector) (cos (aperture sector)) (sin (aperture sector)))))
    (setf (sector-ledge sector) (nv* (car dirs) (radius sector)))
    (setf (sector-redge sector) (nv* (cdr dirs) (radius sector))))
  (let ((points (make-hash-table :test 'eq))
        (blocking-edges (blocking-edges sector))
        (poly (make-array 4 :fill-pointer 0 :adjustable T)))
    (setf (fill-pointer blocking-edges) 0)
    (for:for ((entity over scene))
      (setf (fill-pointer poly) 0)
      (when (fill-edges entity poly)
        (check-polygon poly sector points blocking-edges)))
    (when (allocated-p (vertex-array sector))
      (let ((angle-points (make-array (+ 2 (hash-table-count points)))))
        (setf (aref angle-points 0)
              (v+ (sector-ledge sector) (location sector)))
        (setf (aref angle-points (1- (length angle-points)))
              (v+ (sector-redge sector) (location sector)))
        (loop for i from 1
              for p being the hash-keys of points
              do (setf (aref angle-points i) p))
        (sort-points angle-points sector)
        (let ((rays (make-rays sector angle-points)))
          (destructuring-bind (hit-points . ctrl-points) (shoot-rays rays blocking-edges sector)
            (update-fov-geometry hit-points ctrl-points sector)))))))

(defun eval-quad-bezier-curve (p0 pc p2 tt)
  (let ((t2 (* tt tt))
        (t2- (* (- 1 tt) (- 1 tt))))
    (vec (+ (* t2- (vx p0)) (* 2 (- 1 tt) tt (vx pc)) (* t2 (vx p2)))
         (+ (* t2- (vy p0)) (* 2 (- 1 tt) tt (vy pc)) (* t2 (vy p2))))))

(defun update-fov-geometry (hit-points ctrl-points sector)
  (let* ((loc (location sector))
         (vao (vertex-array sector))
         (vbo (caar (bindings vao)))
         (data (buffer-data vbo))
         prev)
    (setf (fill-pointer data) 0)
    (flet ((emit (p)
             (setf prev p)
             (vector-push-extend (- (vx p) (vx loc)) data)
             (vector-push-extend (- (vy p) (vy loc)) data)))
      (emit loc)
      (loop for p across hit-points
            for cp across ctrl-points
            do (if cp
                   (loop for i from 0 to 1 by 0.1
                         do (emit (eval-quad-bezier-curve prev cp p i)))
                   (emit p))))
    (resize-buffer vbo (* (length data) 4) :data data)
    (setf (size vao) (length data))))

(define-class-shader (sector :fragment-shader)
  "out vec4 color;
void main(){
  color = vec4(1, 0, 0, 0.3);
}")
