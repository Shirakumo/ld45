(in-package #:org.shirakumo.fraf.ld45)

(defstruct (path-map
            (:constructor make-path-map (g w h s v))
            (:copier NIL)
            (:predicate NIL))
  (g NIL :type (simple-array bit (*)))
  (w NIL :type (unsigned-byte 32))
  (h NIL :type (unsigned-byte 32))
  (s NIL :type (unsigned-byte 32))
  (v NIL :type vec2))

(defun compute-path-map (scene &key (grid 32))
  ;; Determine bounds
  (let ((vmin (vec 0 0))
        (vmax (vec 0 0)))
    (for:for ((entity over scene))
      (when (typep entity 'wall)
        (setf vmin (vmin vmin (v- (location entity) (bsize entity))))
        (setf vmax (vmax vmax (v+ (location entity) (bsize entity))))))
    ;; Allocate and fill bit array.
    (let* ((w (+ 2 (ceiling (- (vx vmax) (vx vmin)) grid)))
           (h (+ 2 (ceiling (- (vy vmax) (vy vmin)) grid)))
           (g (make-array (* w h) :element-type 'bit :initial-element 0)))
      (for:for ((entity over scene))
        (when (typep entity 'wall)
          (let ((lb (v- (v- (location entity) (bsize entity)) vmin))
                (ru (v- (v+ (location entity) (bsize entity)) vmin)))
            (loop for y from (floor (vy lb) grid) to (ceiling (vy ru) grid)
                  do (loop for x from (floor (vx lb) grid) to (ceiling (vx ru) grid)
                           for idx = (+ (1+ x) (* (1+ y) w))
                           do (setf (aref g idx) 1))))))
      (make-path-map g w h grid vmin))))

(defun find-path (map start goal)
  ;; A*
  (let* ((g (path-map-g map))
         (w (path-map-w map))
         (s (path-map-s map))
         (vmin (path-map-v map))
         (start (cons (1+ (floor (- (vx start) (vx vmin)) s))
                      (1+ (floor (- (vy start) (vy vmin)) s))))
         (goal  (cons (1+ (floor (- (vx goal) (vx vmin)) s))
                      (1+ (floor (- (vy goal) (vy vmin)) s))))
         (open (list start))
         (cost (make-hash-table :test 'equal))
         (score (make-hash-table :test 'equal))
         (source (make-hash-table :test 'equal)))
    (labels ((cost (c) (gethash c cost))
             (score (c) (gethash c score))
             (source (c) (gethash c source))
             ((setf cost) (value c) (setf (gethash c cost) value))
             ((setf score) (value c) (setf (gethash c score) value))
             ((setf source) (value c) (setf (gethash c source) value))
             (c (c)
               (aref g (+ (car c) (* (cdr c) w))))
             (estimate-cost (c)
               (+ (expt (- (car c) (car goal)) 2)
                  (expt (- (cdr c) (cdr goal)) 2)))
             (current ()
               (let ((min NIL) (min-cost NIL))
                 (dolist (current open min)
                   (let ((cost (cost current)))
                     (when (or (null min-cost) (< cost min-cost))
                       (setf min current)
                       (setf min-cost cost)))))))
      (when (= 0 (c start))
        (setf (score start) (estimate-cost start))
        (loop while open
              for current = (current)
              do (when (equal current goal)
                   (return (loop for current = goal then (source current)
                                 while current collect (nv+ (nv* (vec (car current) (cdr current)) s)
                                                            vmin (/ s -2)))))
                 (setf open (delete current open))
                 (loop for y from (1- (cdr current)) to (1+ (cdr current))
                       do (loop for x from (1- (car current)) to (1+ (car current))
                                for target = (cons x y)
                                do (when (= 0 (c target))
                                     (let ((tentative (1+ (score current)))
                                           (score (score target)))
                                       (when (or (null score) (< tentative score))
                                         (setf (source target) current)
                                         (setf (score target) tentative)
                                         (setf (cost target) (+ tentative (estimate-cost target)))
                                         (pushnew target open :test #'equal)))))))))))
